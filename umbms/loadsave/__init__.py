"""
Tyson Reimer
University of Manitoba
June 19th, 2019
"""


import os
import pickle
import numpy as np

###############################################################################


def load_pickle(path):
    """Loads a pickle file

    Parameters
    ----------
    path : str
        The full path to the .pickle file that will be loaded

    Returns
    -------
    loaded_var :
        The loaded variable, can be array_like, int, str, dict_to_save,
        etc.
    """

    with open(path, 'rb') as handle:
        loaded_var = pickle.load(handle)

    return loaded_var


def save_pickle(var, path):
    """Saves the var to a .pickle file at the path specified

    Parameters
    ----------
    var : object
        A variable that will be saved
    path : str
        The full path of the saved .pickle file
    """

    with open(path, 'wb') as handle:
        pickle.dump(var, handle, protocol=pickle.HIGHEST_PROTOCOL)


def _get_birrs_fd_shape(folder_path):
    """Find number frequencies and antenna positions from birrs .txt

    Parameters
    ----------
    folder_path : str
        Path to the target folder

    Returns
    -------
    n_freqs : int
        Number of scan frequencies
    n_ant_pos : int
        Number of antenna positions
    """

    raw_data = np.zeros([1, ])  # Assign default shape

    possible_files = os.listdir(folder_path)  # Files in the tar dir

    for ii in possible_files:  # Look for a file until one is found

        if 's11' in ii or 'Mono' in ii:  # If birrs .txt file

            # Load the data
            raw_data = np.genfromtxt(os.path.join(folder_path, ii),
                                     dtype='float', delimiter='')
            break  # End loop

    # Find the number of frequencies and scan positions
    n_freqs, n_ant_pos = raw_data.shape
    n_ant_pos //= 2

    return n_freqs, n_ant_pos


def load_birrs_txt(txt_path):
    """Loads a raw .txt file generated by the BIRRS system from a scan

    Loads the file with path txt_path and returns the data stored in
    that arr in the time or frequency domain. Assumes the usual format
    produced by the BIRRS software as of May 7, 2019: for N antenna
    positions, the raw data file contains 2N columns. The first column
    contains the real part of the scattering parameter for the first
    antenna position, the second column contains the imag part, the
    third column contains the real part for the second antenna
    position, etc.

    Parameters
    ----------
    txt_path : str
        The complete path to the file containing the raw data from a
        measured scan, in the BIRRS software format as of May 7, 2019

    Returns
    -------
    fd_data : array_like
        2D arr containing the measured radar signal for each antenna
        position used in the scan, in the frequency domain
    """

    # Load the data
    raw_data = np.genfromtxt(txt_path, dtype='float', delimiter='')

    # Find the number of frequencies and scan positions
    n_freqs, n_ant_pos = raw_data.shape
    n_ant_pos //= 2

    # Initialize arr for storing the frequency domain data
    fd_data = np.zeros([n_freqs, n_ant_pos], dtype=complex)

    for ant_pos in range(n_ant_pos):

        # Combine the real and imaginary parts of the scattering
        # parameter, as they're stored in the file
        fd_data[:, ant_pos] = (raw_data[:, 2 * ant_pos]
                               + 1j * raw_data[:, 2 * ant_pos + 1])

    return fd_data


def clean_birrs_folder(folder_path, id_str='expt'):
    """Clean folder of .txt files generated from BIRRS scan

    Assumes that the data files are '.txt' files, are identified by a
    standard 'exptXX' str, where XX is the experiment number (ex:
    01, 02, ..., 10, 11, etc.), and renames files to 'sAB_exptXX.txt',
    where A is the input port and B is the output port (ex: s21, s11).
    Also removes any 'INCOMPLETE' files generate due to early-stopping
    of the BIRRS system during a scan

    Parameters
    ----------
    folder_path : str
        Path to the folder that will be cleaned
    id_str : str
        Identifying string used to identify experiment / scan files
    """

    # The files in the directory
    fs_in_dir = os.listdir(folder_path)

    for ii in fs_in_dir:  # For each file in the directory

        # If this file is a target file, i.e., it contains 'expt'
        # and the identifier strings 'Mono' or 'Multi', because
        # s11 data is saved with str 'Mono', and s21 data with str
        # 'Multi'
        if (id_str in ii) and ('Mono' in ii or 'Multi' in ii):

            # If the scan was incomplete due to early-stopping of the
            # BIRRS system during a scan
            if 'INCOMPLETE' in ii:

                # Delete the file
                os.remove(os.path.join(folder_path, ii))

            else:  # If the scan was complete

                if 'Mono' in ii:  # If the data was from s11
                    new_name = ('s11_%s%s.txt'
                                % (id_str, ii.split('_')[1][len(id_str):]))
                else:  # If the data was from s21
                    new_name = ('s21_%s%s.txt'
                                % (id_str, ii.split('_')[1][len(id_str):]))

                # Rename the completed scan file
                os.rename(os.path.join(folder_path, ii),
                          os.path.join(folder_path, new_name))


def count_n_scans(folder_path):
    """Return the number of unique scans in a scan folder from BIRRS

    Parameters
    ----------
    folder_path : str
        Path to the folder containing the raw .txt files from the scans

    Returns
    -------
    n_scans : int
        The number of scans used to produce the data in the folder
    """

    # The files in the directory
    fs_in_dir = os.listdir(folder_path)

    n_scans = 0

    for ii in fs_in_dir:  # For each file in the directory

        # If this file is a target file, i.e., it contains 'expt'
        # and the identifier strings 'Mono' or 's11', indicating the
        # scan was from the S11 antenna
        if ('exp' in ii) and ('Mono' in ii or 's11' in ii):

            n_scans += 1

    return n_scans


# TODO: Add support for importing standard .csv metadata
# TODO: Add support for 2 scans only
# TODO: Add support for *NO* reference
def load_birrs_folder(folder_path, id_str, ref_idxs=None,
                      load_s21=True,
                      ref_to_use=0):
    """Return calibrated frequency domain data from birrs session dir

    Note: Assumes only one reference scan in session

    Parameters
    ----------
    folder_path : str
        Path to the session folder
    id_str : str
        Identifying string used to flag experiment / scan files
    load_s21 : bool
        If True, loads s21 too. If False, loads only S11
    ref_idxs : list
        List of the indices of all reference scan
    ref_to_use : int
        The index of the reference to use in the experiment

    Returns
    -------
    s11_cal : array_like
        Calibrated frequency domain data array of S11
    s21_cal : array_like
        Calibrated frequency domain data array of S21
    """

    if ref_idxs is None:  # Deal with default case
        ref_idxs = []

    n_scans = count_n_scans(folder_path=folder_path)  # Get n_scans

    # Find shape of each fd data
    n_fs, n_ants = _get_birrs_fd_shape(folder_path=folder_path)

    # Init array for uncalibrated data
    s11_uncal = np.zeros([n_scans, n_fs, n_ants], dtype=complex)
    s21_uncal = np.zeros([n_scans, n_fs, n_ants], dtype=complex)

    # Clean the birrs folder
    clean_birrs_folder(folder_path=folder_path, id_str=id_str)

    for ii in range(n_scans):  # For each scan

        # Load the scan data, assume fname format %s%d.txt
        s11_uncal[ii, :, :] = \
            load_birrs_txt(os.path.join(folder_path, 's11_%s%d.txt'
                                        % (id_str, ii)))
        if load_s21:
            s21_uncal[ii, :, :] = \
                load_birrs_txt(os.path.join(folder_path, 's21_%s%d.txt'
                                            % (id_str, ii)))

    # Init arr to return
    s11_cal = np.zeros([n_scans - len(ref_idxs), n_fs, n_ants],dtype=complex)
    s21_cal = np.zeros([n_scans - len(ref_idxs), n_fs, n_ants],dtype=complex)

    if len(ref_idxs) != 0:  # If using a reference index
        s11_ref = s11_uncal[ref_to_use, :, :]  # The reference S11
        s21_ref = s21_uncal[ref_to_use, :, :]  # The reference S21
    else:
        s11_ref = 0
        s21_ref = 0

    cc = 0  # Init counter

    for ii in range(n_scans):  # For each experiment

        if ii not in ref_idxs:  # If not the reference scan

            # Calibrate via reference subtraction
            s11_cal[cc, :, :] = s11_uncal[ii, :, :] - s11_ref
            s21_cal[cc, :, :] = s21_uncal[ii, :, :] - s21_ref

            cc += 1  # Increment counter
    if load_s21:
        return s11_cal, s21_cal
    else:
        return s11_cal


def load_dak_csv(csv_path):
    """Load the permittivity data from a DAK-generated .csv file

    Parameters
    ----------
    csf_path : str
        Path to the DAK-generated .csv file

    Returns
    -------
    fs : array_like
        The frequencies, in [Hz], that were used in the measurement
    perm : array_like
        Complex-valued relative permittivity obtained from the DAK
        measurement
    """

    # Load the .csv file
    raw_data = np.genfromtxt(csv_path,
                             delimiter=',',
                             skip_header=10,
                             dtype=float)

    # Get the frequencies, and convert from [MHz] to [Hz]
    fs = raw_data[:, 0] * 1e6

    # Get the complex permittivity
    perm = raw_data[:, 1] - 1j * raw_data[:, 2]

    return fs, perm
